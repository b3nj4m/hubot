// Generated by CoffeeScript 1.9.0
(function() {
  var Adapter, EventEmitter, Q,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  EventEmitter = require('events').EventEmitter;

  Q = require('q');

  Adapter = (function(_super) {
    __extends(Adapter, _super);


    /*
     * An adapter is a specific interface to a chat source for robots.
    #
     * robot - A Robot instance.
     */

    function Adapter(_at_robot) {
      this.robot = _at_robot;
      this.ready = Q(this);
    }


    /*
     * Public: Raw method for sending data back to the chat source. Extend this.
    #
     * envelope - A Object with message, room and user details.
     * strings  - One or more Strings for each message to send.
    #
     * Returns nothing.
     */

    Adapter.prototype.send = function() {
      var envelope, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    };


    /*
     * Public: Raw method for sending emote data back to the chat source.
     * Defaults as an alias for send
    #
     * envelope - A Object with message, room and user details.
     * strings  - One or more Strings for each message to send.
    #
     * Returns nothing.
     */

    Adapter.prototype.emote = function() {
      var envelope, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this.send.apply(this, [envelope].concat(__slice.call(strings)));
    };


    /*
     * Public: Raw method for building a reply and sending it back to the chat
     * source. Extend this.
    #
     * envelope - A Object with message, room and user details.
     * strings  - One or more Strings for each reply to send.
    #
     * Returns nothing.
     */

    Adapter.prototype.reply = function() {
      var envelope, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    };


    /*
     * Public: Raw method for setting a topic on the chat source. Extend this.
    #
     * envelope - A Object with message, room and user details.
     * strings  - One more more Strings to set as the topic.
    #
     * Returns nothing.
     */

    Adapter.prototype.topic = function() {
      var envelope, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    };


    /*
     * Public: Raw method for playing a sound in the chat source. Extend this.
    #
     * envelope - A Object with message, room and user details.
     * strings  - One or more strings for each play message to send.
    #
     * Returns nothing
     */

    Adapter.prototype.play = function() {
      var envelope, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    };


    /*
     * Public: Raw method for invoking the bot to run. Extend this.
    #
     * Returns nothing.
     */

    Adapter.prototype.run = function() {};


    /*
     * Public: Raw method for shutting the bot down. Extend this.
    #
     * Returns nothing.
     */

    Adapter.prototype.close = function() {
      return Q(this);
    };


    /*
     * Public: Dispatch a received message to the robot.
    #
     * Returns nothing.
     */

    Adapter.prototype.receive = function(message) {
      return this.robot.receive(message);
    };


    /*
     * Public: Get an Array of User objects stored in the brain.
    #
     * Returns promise for an Array of User objects.
     */

    Adapter.prototype.users = function() {
      this.robot.logger.warning('@users() is going to be deprecated in 3.0.0 use @robot.brain.users()');
      return this.robot.brain.users();
    };


    /*
     * Public: Get a User object given a unique identifier.
    #
     * Returns promise for a User instance of the specified user.
     */

    Adapter.prototype.userForId = function(id, options) {
      this.robot.logger.warning('@userForId() is going to be deprecated in 3.0.0 use @robot.brain.userForId()');
      return this.robot.brain.userForId(id, options);
    };


    /*
     * Public: Get a User object given a name.
    #
     * Returns promise for a User instance for the user with the specified name.
     */

    Adapter.prototype.userForName = function(name) {
      this.robot.logger.warning('@userForName() is going to be deprecated in 3.0.0 use @robot.brain.userForName()');
      return this.robot.brain.userForName(name);
    };


    /*
     * Public: Get all users whose names match fuzzyName. Currently, match
     * means 'starts with', but this could be extended to match initials,
     * nicknames, etc.
    #
     * Returns promise for an Array of User instances matching the fuzzy name.
     */

    Adapter.prototype.usersForRawFuzzyName = function(fuzzyName) {
      this.robot.logger.warning('@userForRawFuzzyName() is going to be deprecated in 3.0.0 use @robot.brain.userForRawFuzzyName()');
      return this.robot.brain.usersForRawFuzzyName(fuzzyName);
    };


    /*
     * Public: If fuzzyName is an exact match for a user, returns an array with
     * just that user. Otherwise, returns an array of all users for which
     * fuzzyName is a raw fuzzy match (see usersForRawFuzzyName).
    #
     * Returns promise for an Array of User instances matching the fuzzy name.
     */

    Adapter.prototype.usersForFuzzyName = function(fuzzyName) {
      this.robot.logger.warning('@userForFuzzyName() is going to be deprecated in 3.0.0 use @robot.brain.userForFuzzyName()');
      return this.robot.brain.usersForFuzzyName(fuzzyName);
    };


    /*
     * Public: Creates a scoped http client with chainable methods for
     * modifying the request. This doesn't actually make a request though.
     * Once your request is assembled, you can call `get()`/`post()`/etc to
     * send the request.
    #
     * Returns a ScopedClient instance.
     */

    Adapter.prototype.http = function(url) {
      this.robot.logger.warning('@http() is going to be deprecated in 3.0.0 use @robot.http()');
      return this.robot.http(url);
    };

    return Adapter;

  })(EventEmitter);

  module.exports = Adapter;

}).call(this);
