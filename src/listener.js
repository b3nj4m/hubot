// Generated by CoffeeScript 1.9.0
(function() {
  var Listener, Q, TextListener, TextMessage, inspect,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __hasProp = {}.hasOwnProperty;

  Q = require('q');

  inspect = require('util').inspect;

  TextMessage = require('./message').TextMessage;


  /*
   *TODO hooks for testing expected responses
   */

  Listener = (function() {
    Listener.prototype.queueSize = 100;


    /*
     * Listeners receive every message from the chat source and decide if they
     * want to act on it.
     *
     * robot    - A Robot instance.
     * matcher  - A Function that determines if this listener should trigger the
     *            callback.
     * callback - A Function that is triggered if the incoming message matches.
     */

    function Listener(_at_robot, _at_matcher, _at_callback) {
      this.robot = _at_robot;
      this.matcher = _at_matcher;
      this.callback = _at_callback;
      this.queue = [];
      this.inProgress = Q();
    }


    /*
     * Public: Determines if the listener likes the content of the message. If
     * so, a Response built from the given Message is queued for processing.
     *
     * message - A Message instance.
     *
     * Returns false or the result of queueing the response
     */

    Listener.prototype.call = function(message) {
      var match;
      if (match = this.matcher(message)) {
        if (this.regex) {
          this.robot.logger.debug("Message '" + message + "' matched regex /" + (inspect(this.regex)) + "/");
        }
        return this.enqueue(new this.robot.Response(this.robot, message, match));
      } else {
        if (this.regex) {
          this.robot.logger.debug("Message '" + message + "' not matched regex /" + (inspect(this.regex)) + "/");
        }
        return false;
      }
    };


    /*
     * Public: queue a response for processing
     *
     * Returns result of exec or nothing.
     */

    Listener.prototype.enqueue = function(response) {
      if (this.inProgress.isPending() || this.queue.length > 0) {
        if (this.queue.length === this.queueSize) {
          this.queue.shift();
        }
        return this.queue.push(response);
      } else {
        return this.exec(response);
      }
    };


    /*
     * Public: process the reponse queue
     *
     * Returns: nothing.
     */

    Listener.prototype.exec = function(response) {
      this.inProgress = this.callback(response);
      if (!this.inProgress || !Q.isPromise(this.inProgress)) {
        this.inProgress = Q(this.inProgress);
      }
      this.inProgress["finally"]((function(_this) {
        return function() {
          if (_this.queue.length > 0) {
            return _this.exec(_this.queue.shift());
          }
        };
      })(this));
      return this.inProgress;
    };

    return Listener;

  })();

  TextListener = (function(_super) {
    __extends(TextListener, _super);


    /*
     * TextListeners receive every message from the chat source and decide if they
     * want to act on it.
     *
     * robot    - A Robot instance.
     * regex    - A Regex that determines if this listener should trigger the
     *            callback.
     * callback - A Function that is triggered if the incoming message matches.
     */

    function TextListener(_at_robot, _at_regex, _at_callback) {
      this.robot = _at_robot;
      this.regex = _at_regex;
      this.callback = _at_callback;
      TextListener.__super__.constructor.call(this, this.robot, this.regex, this.callback);
      this.matcher = (function(_this) {
        return function(message) {
          if (message instanceof TextMessage) {
            return message.match(_this.regex);
          }
        };
      })(this);
    }

    return TextListener;

  })(Listener);

  module.exports = {
    Listener: Listener,
    TextListener: TextListener
  };

}).call(this);
