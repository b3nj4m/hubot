// Generated by CoffeeScript 1.9.0
(function() {
  var BROBBOT_DEFAULT_ADAPTERS, BROBBOT_DEFAULT_BRAINS, BROBBOT_DOCUMENTATION_SECTIONS, EventEmitter, Fs, HttpClient, Listener, Log, Path, Q, Response, Robot, RobotSegment, TextListener, TextMessage, Url, User, _, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  Url = require('url');

  _ = require('lodash');

  Q = require('q');

  Fs = require('fs');

  Log = require('log');

  Path = require('path');

  HttpClient = require('scoped-http-client');

  EventEmitter = require('events').EventEmitter;

  User = require('./user');

  RobotSegment = require('./robot-segment');

  Response = require('./response');

  _ref = require('./listener'), Listener = _ref.Listener, TextListener = _ref.TextListener;

  TextMessage = require('./message').TextMessage;

  BROBBOT_DEFAULT_ADAPTERS = ['campfire', 'shell'];

  BROBBOT_DEFAULT_BRAINS = ['dumb'];

  BROBBOT_DOCUMENTATION_SECTIONS = ['description', 'dependencies', 'configuration', 'commands', 'notes', 'author', 'authors', 'examples', 'tags', 'urls'];

  Robot = (function() {

    /*
     * Robots receive messages from a chat source (Campfire, irc, etc), and
     * dispatch them to matching listeners.
    #
     * scripts - An array of string modules names to load
     * adapter - A string adapter name or an adapter constructor.
     * brain - A string brain name or a brain constructor.
     * httpd - A boolean whether to enable the HTTP daemon.
     * name - A string of the robot name, defaults to Brobbot.
    #
     * Returns nothing.
     */
    function Robot(scripts, adapter, brain, httpd, name) {
      if (name == null) {
        name = 'Brobbot';
      }
      this.name = name;
      this.nameRegex = new RegExp("^\\s*@?" + name + ":?\\s+", 'i');
      this.events = new EventEmitter();
      this.alias = false;
      this.adapter = null;
      this.Response = Response;
      this.commands = [];
      this.listeners = {
        text: [],
        respond: [],
        topic: [],
        enter: [],
        leave: [],
        "catch": []
      };

      /*
      #TODO namespaced logger per-script
       */
      this.logger = new Log(process.env.BROBBOT_LOG_LEVEL || 'info');
      this.pingIntervalId = null;
      this.parseVersion();
      if (httpd) {
        this.setupExpress();
      } else {
        this.setupNullRouter();
      }
      this.brainReady = this.loadBrain(brain);
      this.scriptsReady = this.loadScripts(scripts);
      this.adapterReady = this.loadAdapter(adapter);
      this.ready = Q.all([this.brainReady, this.scriptsReady]);
      this.connected = this.adapterReady;
      this.adapterName = adapter;
      this.errorHandlers = [];
      this.ready.fail((function(_this) {
        return function(err) {
          return _this.logger.error(err.stack);
        };
      })(this));
      this.on('error', (function(_this) {
        return function(err, msg) {
          return _this.invokeErrorHandlers(err, msg);
        };
      })(this));
      process.on('uncaughtException', (function(_this) {
        return function(err) {
          _this.logger.error(err.stack);
          return _this.emit('error', err);
        };
      })(this));
    }


    /*
     * Public: Adds a Listener that attempts to match incoming messages based on
     * a Regex.
    #
     * regex    - A Regex that determines if the callback should be called.
     * callback - A Function that is called with a Response object.
    #
     * Returns nothing.
     */

    Robot.prototype.hear = function(regex, callback) {
      return this.listeners.text.push(new TextListener(this, regex, callback));
    };


    /*
     * Public: Adds a Listener that attempts to match incoming messages directed
     * at the robot based on a Regex. All regexes treat patterns like they begin
     * with a '^'
    #
     * regex    - A Regex that determines if the callback should be called.
     * callback - A Function that is called with a Response object.
    #
     * Returns nothing.
     */

    Robot.prototype.respond = function(regex, callback) {
      return this.listeners.respond.push(new TextListener(this, regex, callback));
    };


    /*
     * Public: Adds a Listener that triggers when anyone enters the room.
    #
     * callback - A Function that is called with a Response object.
    #
     * Returns nothing.
     */

    Robot.prototype.enter = function(callback) {
      return this.listeners.enter.push(new Listener(this, (function(msg) {
        return true;
      }), callback));
    };


    /*
     * Public: Adds a Listener that triggers when anyone leaves the room.
    #
     * callback - A Function that is called with a Response object.
    #
     * Returns nothing.
     */

    Robot.prototype.leave = function(callback) {
      return this.listeners.leave.push(new Listener(this, (function(msg) {
        return true;
      }), callback));
    };


    /*
     * Public: Adds a Listener that triggers when anyone changes the topic.
    #
     * callback - A Function that is called with a Response object.
    #
     * Returns nothing.
     */

    Robot.prototype.topic = function(callback) {
      return this.listeners.topic.push(new Listener(this, (function(msg) {
        return true;
      }), callback));
    };


    /*
     * Public: Adds an error handler when an uncaught exception or user emitted
     * error event occurs.
    #
     * callback - A Function that is called with the error object.
    #
     * Returns nothing.
     */

    Robot.prototype.error = function(callback) {
      return this.errorHandlers.push(callback);
    };


    /*
     * Calls and passes any registered error handlers for unhandled exceptions or
     * user emitted error events.
    #
     * err - An Error object.
     * msg - An optional Response object that generated the error
    #
     * Returns nothing.
     */

    Robot.prototype.invokeErrorHandlers = function(err, msg) {
      var errErr, errorHandler, _i, _len, _ref1, _results;
      this.logger.error(err.stack);
      _ref1 = this.errorHandlers;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        errorHandler = _ref1[_i];
        try {
          _results.push(errorHandler(err, msg));
        } catch (_error) {
          errErr = _error;
          _results.push(this.logger.error("while invoking error handler: " + errErr + "\n" + errErr.stack));
        }
      }
      return _results;
    };


    /*
     * Public: Adds a Listener that triggers when no other text matchers match.
    #
     * callback - A Function that is called with a Response object.
    #
     * Returns nothing.
     */

    Robot.prototype.catchAll = function(callback) {
      return this.listeners["catch"].push(new Listener(this, (function(msg) {
        return true;
      }), (function(msg) {
        msg.message = msg.message.message;
        return callback(msg);
      })));
    };

    Robot.prototype.messageIsToMe = function(message) {
      if (this.alias) {
        this.aliasRegex = new RegExp("^\\s*@?" + this.alias + ":?\\s+", 'i');
      } else {
        this.aliasRegex = false;
      }
      return this.nameRegex.test(message.text) || (this.aliasRegex && this.aliasRegex.test(message.text));
    };


    /*
     * Public: Passes the given message to any interested Listeners.
    #
     * message - A Message instance. Listeners can flag this message as 'done' to
     *           prevent further execution.
    #
     * Returns nothing.
     */

    Robot.prototype.receive = function(message) {
      return this.connected.then((function(_this) {
        return function() {
          var error, listener, matched, respondMessage, respondText, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _results;
          matched = false;
          message.isAddressedToBrobbot = _this.messageIsToMe(message);
          _ref1 = _this.listeners[message._type];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            listener = _ref1[_i];
            try {
              matched = listener.call(message) || matched;
              if (message.done) {
                break;
              }
            } catch (_error) {
              error = _error;
              _this.emit('error', error, new _this.Response(_this, message, []));
            }
          }
          if (message.isAddressedToBrobbot) {

            /*
            #for respond listeners, chop off the brobbot's name/alias
             */
            respondText = message.text.replace(_this.nameRegex, '');
            if (_this.aliasRegex) {
              respondText = respondText.replace(_this.aliasRegex, '');
            }
            respondMessage = new TextMessage(message.user, respondText, message.id);
            respondMessage.isAddressedToBrobbot = message.isAddressedToBrobbot;
            _ref2 = _this.listeners.respond;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              listener = _ref2[_j];
              try {
                matched = listener.call(respondMessage) || matched;
                if (respondMessage.done) {
                  break;
                }
              } catch (_error) {
                error = _error;
                _this.emit('error', error, new _this.Response(_this, respondMessage, []));
              }
            }
          }
          if (!matched) {
            _ref3 = _this.listeners["catch"];
            _results = [];
            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
              listener = _ref3[_k];
              listener.call(message);
              if (message.done) {
                break;
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          }
        };
      })(this));
    };

    Robot.prototype.loadScripts = function(scripts) {
      return this.brainReady.then((function(_this) {
        return function() {
          return Q.all(_.map(scripts, function(script) {
            return _this.loadScript(script);
          }));
        };
      })(this));
    };

    Robot.prototype.loadScript = function(script) {
      var err, path;
      try {
        path = "brobbot-" + script;
        require.resolve(path);
      } catch (_error) {
        err = _error;
        path = script;
      }
      try {
        return Q(require(path)(this.segment(script)));
      } catch (_error) {
        err = _error;
        return Q.reject(err);
      }
    };


    /*
     * Setup the Express server's defaults.
    #
     * Returns nothing.
     */

    Robot.prototype.setupExpress = function() {
      var app, err, express, herokuUrl, pass, stat, user;
      user = process.env.EXPRESS_USER;
      pass = process.env.EXPRESS_PASSWORD;
      stat = process.env.EXPRESS_STATIC;
      express = require('express');
      app = express();
      app.use((function(_this) {
        return function(req, res, next) {
          res.setHeader("X-Powered-By", "brobbot/" + _this.name);
          return next();
        };
      })(this));
      if (user && pass) {
        app.use(express.basicAuth(user, pass));
      }
      app.use(express.query());
      app.use(express.bodyParser());
      if (stat) {
        app.use(express["static"](stat));
      }
      try {
        this.server = app.listen(process.env.PORT || 8080, process.env.BIND_ADDRESS || '0.0.0.0');
        this.router = app;
      } catch (_error) {
        err = _error;
        this.logger.error("Error trying to start HTTP server: " + err + "\n" + err.stack);
        this.shutdown(1);
      }
      herokuUrl = process.env.HEROKU_URL;
      if (herokuUrl) {
        if (!Url.parse(herokuUrl).protocol) {
          herokuUrl = 'http://' + herokuUrl;
        }
        if (!/\/$/.test(herokuUrl)) {
          herokuUrl += '/';
        }
        return this.pingIntervalId = setInterval((function(_this) {
          return function() {
            return HttpClient.create(herokuUrl + "brobbot/ping").post()(function(err, res, body) {
              return _this.logger.info('keep alive ping!');
            });
          };
        })(this), 5 * 60 * 1000);
      }
    };


    /*
     * Setup an empty router object
    #
     * returns nothing
     */

    Robot.prototype.setupNullRouter = function() {
      var msg;
      msg = "A script has tried registering a HTTP route while the HTTP server is disabled with --disabled-httpd.";
      return this.router = {
        get: (function(_this) {
          return function() {
            return _this.logger.warning(msg);
          };
        })(this),
        post: (function(_this) {
          return function() {
            return _this.logger.warning(msg);
          };
        })(this),
        put: (function(_this) {
          return function() {
            return _this.logger.warning(msg);
          };
        })(this),
        "delete": (function(_this) {
          return function() {
            return _this.logger.warning(msg);
          };
        })(this)
      };
    };


    /*
     * Given a brain name, resolve to a module path
    #
     * brain - string brain name
    #
     * returns string path
     */

    Robot.prototype.resolveBrain = function(brain) {
      var err, path;
      path = __indexOf.call(BROBBOT_DEFAULT_BRAINS, brain) >= 0 ? "./brains/" + brain : "brobbot-" + brain + "-brain";
      try {
        require.resolve(path);
      } catch (_error) {
        err = _error;
        path = brain;
      }
      return path;
    };


    /*
     * Load the brain Brobbot is going to use.
    #
     * brain - A String of the brain name to use or a Brain constructor.
    #
     * Returns promise.
     */

    Robot.prototype.loadBrain = function(brain) {
      var BrainFn, err, path;
      brain = brain || 'dumb';
      this.logger.debug("Loading brain " + brain);
      if (_.isString(brain)) {
        path = this.resolveBrain(brain);
      }
      try {
        BrainFn = _.isFunction(brain) && brain || require(path);
        this.brain = new BrainFn(this);
        return this.brain.ready || Q(this.brain);
      } catch (_error) {
        err = _error;
        this.logger.error("Cannot load brain " + brain + " - " + err.stack);
        return this.shutdown(1);
      }
    };


    /*
     * given an adapter name, resolve module path
    #
     * adapter - adapter name string
    #
     * returns string path
     */

    Robot.prototype.resolveAdapter = function(adapter) {
      var err, path;
      path = __indexOf.call(BROBBOT_DEFAULT_ADAPTERS, adapter) >= 0 ? "./adapters/" + adapter : "brobbot-" + adapter;
      try {
        require.resolve(path);
      } catch (_error) {
        err = _error;
        path = adapter;
      }
      return path;
    };


    /*
     * Load the adapter Brobbot is going to use.
    #
     * adapter - A String of the adapter name to use or an Adapter constructor.
    #
     * Returns promise.
     */

    Robot.prototype.loadAdapter = function(adapter) {
      var AdapterFn, err, path;
      adapter = adapter || 'shell';
      this.logger.debug("Loading adapter " + adapter);
      if (_.isString(adapter)) {
        path = this.resolveAdapter(adapter);
      }
      try {
        AdapterFn = _.isFunction(adapter) && adapter || require(path);
        this.adapter = new AdapterFn(this);
        return this.adapter.ready || Q(this.adapter);
      } catch (_error) {
        err = _error;
        this.logger.error("Cannot load adapter " + adapter + " - " + err.stack);
        return this.shutdown(1);
      }
    };


    /*
     * Public: Help Commands for Running Scripts.
    #
     * Returns an Array of help commands for running scripts.
     */

    Robot.prototype.helpCommands = function() {
      return _.map(this.commands, function(command) {
        return command.command + ' - ' + command.description;
      });
    };


    /*
     * Public: add a help command
     */

    Robot.prototype.helpCommand = function(command, description) {
      return this.commands.push({
        command: command,
        description: description
      });
    };


    /*
     * Public: A helper send function which delegates to the adapter's send
     * function.
    #
     * user    - A User instance.
     * strings - One or more Strings for each message to send.
    #
     * Returns nothing.
     */

    Robot.prototype.send = function() {
      var strings, user, _ref1;
      user = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (_ref1 = this.adapter).send.apply(_ref1, [user].concat(__slice.call(strings)));
    };


    /*
     * Public: A helper reply function which delegates to the adapter's reply
     * function.
    #
     * user    - A User instance.
     * strings - One or more Strings for each message to send.
    #
     * Returns nothing.
     */

    Robot.prototype.reply = function() {
      var strings, user, _ref1;
      user = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (_ref1 = this.adapter).reply.apply(_ref1, [user].concat(__slice.call(strings)));
    };


    /*
     * Public: A helper send function to message a room that the robot is in.
    #
     * room    - String designating the room to message.
     * strings - One or more Strings for each message to send.
    #
     * Returns nothing.
     */

    Robot.prototype.messageRoom = function() {
      var room, strings, user, _ref1;
      room = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      user = {
        room: room
      };
      return (_ref1 = this.adapter).send.apply(_ref1, [user].concat(__slice.call(strings)));
    };


    /*
     * Public: A wrapper around the EventEmitter API to make usage
     * semanticly better.
    #
     * event    - The event name.
     * listener - A Function that is called with the event parameter
     *            when event happens.
    #
     * Returns nothing.
     */

    Robot.prototype.on = function() {
      var args, event, _ref1;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (_ref1 = this.events).on.apply(_ref1, [event].concat(__slice.call(args)));
    };


    /*
     * Public: A wrapper around the EventEmitter API to make usage
     * semanticly better.
    #
     * event   - The event name.
     * args...  - Arguments emitted by the event
    #
     * Returns nothing.
     */

    Robot.prototype.emit = function() {
      var args, event, _ref1;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (_ref1 = this.events).emit.apply(_ref1, [event].concat(__slice.call(args)));
    };


    /*
     * Public: Kick off the event loop for the adapter
    #
     * Returns nothing.
     */

    Robot.prototype.run = function() {
      return this.ready.then((function(_this) {
        return function() {
          _this.emit("running");
          return _this.adapter.run();
        };
      })(this));
    };


    /*
     * Public: Gracefully shutdown the robot process
    #
     * Returns nothing.
     */

    Robot.prototype.shutdown = function(exitCode) {
      var closing;
      this.logger.info("shutting down...");
      if (this.pingIntervalId != null) {
        clearInterval(this.pingIntervalId);
      }
      closing = [];
      if (this.adapter) {
        closing.push(this.adapter.close());
      }
      if (this.brain) {
        closing.push(this.brain.close());
      }
      return Q.all(closing)["finally"](function() {
        return process.exit(exitCode || 0);
      });
    };

    Robot.prototype.parseVersion = function() {
      return this.version = require('../package.json').version;
    };


    /*
     * Public: Creates a scoped http client with chainable methods for
     * modifying the request. This doesn't actually make a request though.
     * Once your request is assembled, you can call `get()`/`post()`/etc to
     * send the request.
    #
     * url - String URL to access.
    #
     * Examples:
    #
     *     res.http("http://example.com")
     *       # set a single header
     *       .header('Authorization', 'bearer abcdef')
    #
     *       # set multiple headers
     *       .headers(Authorization: 'bearer abcdef', Accept: 'application/json')
    #
     *       # add URI query parameters
     *       .query(a: 1, b: 'foo & bar')
    #
     *       # make the actual request
     *       .get() (err, res, body) ->
     *         console.log body
    #
     *       # or, you can POST data
     *       .post(data) (err, res, body) ->
     *         console.log body
    #
     * Returns a ScopedClient instance.
     */

    Robot.prototype.http = function(url) {
      return HttpClient.create(url).header('User-Agent', "Brobbot/" + this.version);
    };

    Robot.prototype.segment = function(segmentName) {
      return new RobotSegment(this, segmentName);
    };

    return Robot;

  })();

  module.exports = Robot;

}).call(this);
